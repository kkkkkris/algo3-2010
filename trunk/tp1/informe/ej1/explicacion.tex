La estructura soporte utilizada en el algoritmo es una matriz de 3 x n que denominamos Tabla en el algoritmo para mayor claridad.
La Tabla almacena para cada fila i: en una columna el elemento  i de la secuencia, en otra el tamanio de la máxima subsecuencia creciente desde 1 hasta i que incluye al elemento i de la secuencia, y en la tercera , el tamaño de la máxima subsecuencia decreciente desde  i hasta n que incluye al elemento i de la secuencia.
Para mejor comprensión indexaremos la tabla como tabla[index\_de\_secuencia][number/up/down] donde la columna number  tiene el elemento en si,la columna up el tamaño de máxima subsecuencia creciente y la columna down el tamaño de máxima subsecuencia decreciente.
En tabla[0][number] se guardara el tamaño de la secuencia y lo notamos como n en los algoritmos

Pseudocódigo
$/*$función principal que calcula la cantidad mínima de elementos de una secuencia que hay que eliminar para que la secuencia resultante sea unimodal.$*\$

\begin{verbatim}
 calcularMin(Table t)
    para i=1,i<n                 O(n2)
	   llenar_tablaup(t,i) 
	para i=n,i>0                   O(n^2)
	  llenar_tabladown(t,i)
    
    max= unimodalMax(t)            O(n)
    devolver n-max   
                                 ____
                        total:    O(n^2)
\end{verbatim}                       
 
Los dos O($n^{2}$) de los ciclos que aplican llenar\_tablaup y llenar\_tabladown provienen de la siguientes sumatorias:
el primer ciclo hace 
$\sum_{i=1}^{i=n} i $ = n(n+1)$/$2 = O($n^{2}$)
mientras que el segundo
$\sum_{i=1}^{i=n}(n-i)$ = $\sum_{i=1}^{i=n}(i-1)$ = (n-1)n$/$2 = O($n^{2}$)
                       
$/*$función que llena una fila de la tabla con los tamaños de máxima subsecuencia creciente desde 1 hasta i que incluyen el elemento i  $/*$

\begin{verbatim}                        
llenar\_tablaup(tabla,i)           
   para j=i-1,j>0,j--				O(i)   
     m= max\_predecesor?(tabla,i,m) 	
   devolver m+1;
\end{verbatim}    
        

$/*$función que llena una fila de la tabla con los tamaños de máxima subsecuencia decreciente desde i hasta n que incluyen el elemento i $/*$ 
       
\begin{verbatim}                        
llenar\_tabladown(tabla,i)             
   para j=i+1,j$<$n,j++			   O(n-i) 
      m= max\_predecesor?(tabla,i,m) 	
   devolver m+1;
\end{verbatim} 
max\_predecesor?(tabla,i,m) son comparaciones O(1) que devuelven el maximo predecesor hasta el elemento i. 

$/*$función que una vez obtenidos los tamaños de máxima subsecuencia creciente y máxima subsecuencia decreciente 
realiza la búsqueda de la combinación de ambas que conforman la máxima secuencia unimodal y devuelve el tamaño de la misma.
Observar que cuenta con dos casos que analizamos aisladamente fuera de la iteración o "casos base", que son casobase1: que la secuencia unimodal máxima sea toda creciente e incluya al último elemento(n),corresponde al valor de tabla$[n][up]$ y casobase2: que sea toda decreciente e incluya al primero (1), corresponde al valor de tabla$[1][down]$ 
El maxup\_actual e i\_maxup\_actual son variables que guardan el mayor tamaño de subsecuencia creciente hasta el momento y su respectivo indice sin la condición de que incluyan al elemento actual iterado, ésto es que no necesariamente van a coincidir , por ejemplo para la secuencia 3-4-5-6-1-2  en i=6 tenemos que maxup\_actual es 4 (de la subsecuencia 3-4-5-6) mientras que tabla$[6][up]$ =2 (de la subsecuencia 1-2) $/*$
\begin{verbatim}
unimodalMax(tabla)
    int max,maxup\_actual,i\_maxup\_actual,aux\_max; 	
    max= si(casobase1 >casobase2) ?casobase1 :casobase2 ;
	
	para k=1,k$<$n,k++          							   O(n)
	   si tabla[k][up]$>$maxup\_actual	
	      seteo nuevo maxup\_actual
       finsi 
       aux\_max=maxup\_actual+tabla[k+1][down]		   
	   si aux\_max>max
	      si los extremos de subsecuencias up y down son $\not =$
	         max=aux
	      si no 
	         max=aux-1
    	  finsi 
	    finsi
	 finpara   
   devolver max

\end{verbatim}

Lo que hacemos en el algoritmo es mantener actualizada la subsecuencia creciente maxima en maxup\_actual para el i en cuestion y sumarlo sobre todas las subsecuencias decrecientes máximas para ese mismo i. 

Sea  lu$_i$ =$\max_{i\leq k<n}$ l$_k$+ 1 $\forall$i $1\leq i \leq n$ tal que x$_k$ $<$ x$_i$  (lu=long up)

Sea  ld$_i$ =$\max_{i<k\leq n}$ l$_k$+ 1 $\forall$i $1\leq i \leq n$ tal que x$_k$ $<$ x$_i$  (ld=long down)

Luego maxSecUnimodal = max((lu$_i$+ld$_j$),lu$_n$,ld$_1$)\hspace{0.1cm} $\forall$ i,j, $1\leq i<j\leq n$,x${_i} \not =$x${_j}$ 
\newline
El principio de optimalidad vale para ambos algoritmos de búsqueda de subsecuencia creciente y decreciente mas larga y se podria enunciar así : 
\newline
Si una subsecuencia es óptima, no puede haber elementos entre los elementos de la subsecuencia que formen otra subsecuencia mejor que las subsecuencias que forman los elementos de la óptima, en otras palabras, las subsecuencias formadas por los elementos de la óptima, son óptimas para esa longitud.
Luego hallando la mejor combinación entre subsecuencia creciente y subsecuencia decreciente, obtenemos la subsecuencia unimodal óptima. 
\newline
Llamemos S  a la secuencia a analizar y SC${_i}$ a la subsecuencia creciente maxima para S[1..i] y SD${_i}$ a la subsecuencia decreciente maxima para S[i..n].
\newline
Llamemos U${_i}$ a la subsecuencia unimodal máxima que tiene al elemento S${_i}$ como su pico máximo.
Tenemos entonces que necesariamente U${_i}$ está formada por SC${_i}$ +  SD${_i}{_+}{_1}$ siempre que los elementos ultimo de SC${_i}$ y primero de SD${_i}{_+}{_1}$, es decir los que se concatenan, sean distintos, si son iguales ,U${_i}$ es la concatenacion de ellos eliminando uno de los dos repetidos.
\newline
Luego tendremos la subsecuencia unimodal máxima en $\max_{1\leq i\leq n}$ U${_i}$ .
\newline